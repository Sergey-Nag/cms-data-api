const mockUsers = require('./__mocks__/users.json');
const data = require('../data/index.js');
const UserRepository = require('../data/repositories/UserRepository.js');
const envVariables = require('../constants/env.js');
const { setup } = require('../data/setup.js');
const { USERS_REPO_NAME, USER_CREDS_REPO_NAME } = require('../constants/repositoryNames.js');
const User = require('../data/models/users/User.js');

jest.mock('../data/index.js')
jest.mock('../constants/env.js', () => ({
    ADMIN_PASSWORD: 'admin-password',
    ADMIN_ID: 'admin-id',
    ADMIN_EMAIL: 'admin',
}));

describe('Autogenerated admin user', () => {
    afterEach(() => {
        jest.clearAllMocks();
    })

    it('Should create admin if no users created yet', async () => {
        const mockWriteFn = jest.fn();
        jest.spyOn(data, 'readData').mockResolvedValue([]);
        jest.spyOn(data, 'writeData').mockImplementation(mockWriteFn)

        const usersRepo = new UserRepository()
        await usersRepo.load();

        expect(usersRepo.data).toHaveLength(0);
        verifyAdminShouldNotExist(usersRepo)

        await setup();

        expect(usersRepo.data).toHaveLength(1);
        const admin = verifyAdminShouldExist(usersRepo);

        expect(mockWriteFn).toHaveBeenCalledWith(USER_CREDS_REPO_NAME, expect.arrayContaining([
            expect.objectContaining({ id: envVariables.ADMIN_ID })
        ]));
        expect(mockWriteFn).toHaveBeenCalledWith(USERS_REPO_NAME, expect.arrayContaining([
            expect.objectContaining(admin)
        ]));
    });

    it('Should create admin if it does not exist among users and push it on first place in array', async () => {
        const mockWriteFn = jest.fn();
        jest.spyOn(data, 'readData').mockResolvedValue([...mockUsers]);
        jest.spyOn(data, 'writeData').mockImplementation(mockWriteFn)

        const usersRepo = new UserRepository()
        await usersRepo.load();

        expect(usersRepo.data).toHaveLength(5);
        verifyAdminShouldNotExist(usersRepo)

        await setup();

        expect(usersRepo.data).toHaveLength(6);
        const admin = verifyAdminShouldExist(usersRepo);

        expect(mockWriteFn).toHaveBeenCalledWith(USER_CREDS_REPO_NAME, expect.arrayContaining([
            expect.objectContaining({ id: envVariables.ADMIN_ID })
        ]));
        expect(mockWriteFn).toHaveBeenCalledWith(USERS_REPO_NAME, expect.arrayContaining([
            expect.objectContaining(admin)
        ]));
    });

    it('Should not create admin if it is already exist', async () => {
        const mockWriteFn = jest.fn();
        const mockUsersWithAdmin = [
            new User({
                id: envVariables.ADMIN_ID,
                firstname: 'Admin',
                email: envVariables.ADMIN_EMAIL,
                permissions: {
                    canSee: {
                        analytics: true,
                        users: true,
                        pages: true,
                        products: true,
                        orders: true,
                    },
                    canEdit: {
                        analytics: true,
                        users: true,
                        pages: true,
                        products: true,
                        orders: true,
                    },
                    canDelete: {
                        analytics: true,
                        users: true,
                        pages: true,
                        products: true,
                        orders: true,
                    },
                }
            }),
            ...mockUsers
        ];
        jest.spyOn(data, 'readData').mockResolvedValue(mockUsersWithAdmin);
        jest.spyOn(data, 'writeData').mockImplementation(mockWriteFn)

        const usersRepo = new UserRepository()
        await usersRepo.load();

        expect(usersRepo.data).toHaveLength(6);
        verifyAdminShouldExist(usersRepo)

        await setup();

        expect(usersRepo.data).toHaveLength(6);
        verifyAdminShouldExist(usersRepo);
        expect(mockWriteFn).not.toHaveBeenCalled();
    });
});

function verifyAdminShouldNotExist(usersRepo) {
    const admin = usersRepo.get({ id: envVariables.ADMIN_ID });

    expect(admin).toBeNull();
}

function verifyAdminShouldExist(usersRepo) {
    const admin = usersRepo.get({ id: envVariables.ADMIN_ID });

    expect(admin).not.toBeNull();

    expect(usersRepo.data[0]).toHaveProperty('id', envVariables.ADMIN_ID);
    expect(admin).toHaveProperty('id', envVariables.ADMIN_ID);
    expect(admin).toHaveProperty('firstname', 'Admin');
    expect(admin).toHaveProperty('email', envVariables.ADMIN_EMAIL);
    expect(admin).toHaveProperty('permissions', {
        canSee: {
            analytics: true,
            users: true,
            pages: true,
            products: true,
            orders: true,
        },
        canEdit: {
            analytics: true,
            users: true,
            pages: true,
            products: true,
            orders: true,
        },
        canDelete: {
            analytics: true,
            users: true,
            pages: true,
            products: true,
            orders: true,
        },
    });

    return admin;
}