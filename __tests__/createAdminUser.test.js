const mockAdmins = require('./__mocks__/admins.json');
const data = require('../data/index.js');
const envVariables = require('../constants/env.js');
const { setup } = require('../data/setup.js');
const { USER_CREDS_REPO_NAME, ADMINS_REPO_NAME } = require('../constants/repositoryNames.js');
const User = require('../data/models/users/User.js');
const Repository = require('../data/repositories/Repository');
const Admin = require('../data/models/users/Admin');

jest.mock('../data/index.js')
jest.mock('../constants/env.js', () => ({
    ADMIN_PASSWORD: 'admin-password',
    ADMIN_ID: 'admin-id',
    ADMIN_EMAIL: 'admin',
}));

describe('Autogenerated admin user', () => {
    afterEach(() => {
        jest.clearAllMocks();
    })

    it('Should create admin if no users created yet', async () => {
        const mockWriteFn = jest.fn();
        jest.spyOn(data, 'readData').mockResolvedValue([]);
        jest.spyOn(data, 'writeData').mockImplementation(mockWriteFn)

        const usersRepo = new Repository(ADMINS_REPO_NAME)
        await usersRepo.load();

        expect(usersRepo.data).toHaveLength(0);
        verifyAdminShouldNotExist(usersRepo)

        await setup();

        expect(usersRepo.data).toHaveLength(1);
        const admin = verifyAdminShouldExist(usersRepo);

        expect(mockWriteFn).toHaveBeenCalledWith(ADMINS_REPO_NAME, expect.arrayContaining([
            expect.objectContaining(admin)
        ]));
    });

    it('Should create admin if it does not exist among users and push it on first place in array', async () => {
        const mockWriteFn = jest.fn();
        jest.spyOn(data, 'readData').mockResolvedValue([...mockAdmins]);
        jest.spyOn(data, 'writeData').mockImplementation(mockWriteFn)

        const usersRepo = new Repository(ADMINS_REPO_NAME)
        await usersRepo.load();

        expect(usersRepo.data).toHaveLength(5);
        verifyAdminShouldNotExist(usersRepo)

        await setup();

        expect(usersRepo.data).toHaveLength(6);
        const admin = verifyAdminShouldExist(usersRepo);

        expect(mockWriteFn).toHaveBeenCalledWith(ADMINS_REPO_NAME, expect.arrayContaining([
            expect.objectContaining(admin)
        ]));
    });

    it('Should not create admin if it is already exist', async () => {
        const mockWriteFn = jest.fn();
        const mockAdminsWithAdmin = [
            new Admin({
                id: envVariables.ADMIN_ID,
                firstname: 'Admin',
                email: envVariables.ADMIN_EMAIL,
                permissions: {
                    canSee: {
                        analytics: true,
                        pages: true,
                        products: true,
                        orders: true,
                        admins: true,
                        customers: true,
                    },
                    canEdit: {
                        analytics: true,
                        pages: true,
                        products: true,
                        orders: true,
                        admins: true,
                        customers: true,
                    },
                    canDelete: {
                        analytics: true,
                        pages: true,
                        products: true,
                        orders: true,
                        admins: true,
                        customers: true,
                    },
                }
            }),
            ...mockAdmins
        ];
        jest.spyOn(data, 'readData').mockResolvedValue(mockAdminsWithAdmin);
        jest.spyOn(data, 'writeData').mockImplementation(mockWriteFn)

        const usersRepo = new Repository(ADMINS_REPO_NAME)
        await usersRepo.load();

        expect(usersRepo.data).toHaveLength(6);
        verifyAdminShouldExist(usersRepo)

        await setup();

        expect(usersRepo.data).toHaveLength(6);
        verifyAdminShouldExist(usersRepo);
        expect(mockWriteFn).not.toHaveBeenCalled();
    });
});

function verifyAdminShouldNotExist(usersRepo) {
    const admin = usersRepo.get(({id}) => id === envVariables.ADMIN_ID);

    expect(admin).toBeNull();
}

function verifyAdminShouldExist(usersRepo) {
    const admin = usersRepo.get(({id}) => id === envVariables.ADMIN_ID);

    expect(admin).not.toBeNull();

    expect(usersRepo.data[0]).toHaveProperty('id', envVariables.ADMIN_ID);
    expect(admin).toHaveProperty('id', envVariables.ADMIN_ID);
    expect(admin).toHaveProperty('firstname', 'Admin');
    expect(admin).toHaveProperty('email', envVariables.ADMIN_EMAIL);
    expect(admin).toHaveProperty('permissions', {
        canSee: {
            analytics: true,
            pages: true,
            products: true,
            orders: true,
            admins: true,
            customers: true,
        },
        canEdit: {
            analytics: true,
            pages: true,
            products: true,
            orders: true,
            admins: true,
            customers: true,
        },
        canDelete: {
            analytics: true,
            pages: true,
            products: true,
            orders: true,
            admins: true,
            customers: true,
        },
    });
    expect(admin._secret.hashedPassword).not.toBe(envVariables.ADMIN_PASSWORD);

    return admin;
}